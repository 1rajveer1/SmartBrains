{"ast":null,"code":"import _classCallCheck from \"C:/Users/Polymorph/Desktop/face_recognizer/face_recognition_app/SmartBrains/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Polymorph/Desktop/face_recognizer/face_recognition_app/SmartBrains/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange } from \"tsparticles-engine\";\nexport var OutOutMode = /*#__PURE__*/function () {\n  function OutOutMode(container) {\n    _classCallCheck(this, OutOutMode);\n    this.container = container;\n    this.modes = [\"out\"];\n  }\n  _createClass(OutOutMode, [{\n    key: \"update\",\n    value: function update(particle, direction, delta, outMode) {\n      if (!this.modes.includes(outMode)) {\n        return;\n      }\n      var container = this.container;\n      switch (particle.outType) {\n        case \"inside\":\n          {\n            var _particle$velocity = particle.velocity,\n              vx = _particle$velocity.x,\n              vy = _particle$velocity.y;\n            var circVec = Vector.origin;\n            circVec.length = particle.moveCenter.radius;\n            circVec.angle = particle.velocity.angle + Math.PI;\n            circVec.addTo(Vector.create(particle.moveCenter));\n            var _getDistances = getDistances(particle.position, circVec),\n              dx = _getDistances.dx,\n              dy = _getDistances.dy;\n            if (vx <= 0 && dx >= 0 || vy <= 0 && dy >= 0 || vx >= 0 && dx <= 0 || vy >= 0 && dy <= 0) {\n              return;\n            }\n            particle.position.x = Math.floor(randomInRange({\n              min: 0,\n              max: container.canvas.size.width\n            }));\n            particle.position.y = Math.floor(randomInRange({\n              min: 0,\n              max: container.canvas.size.height\n            }));\n            var _getDistances2 = getDistances(particle.position, particle.moveCenter),\n              newDx = _getDistances2.dx,\n              newDy = _getDistances2.dy;\n            particle.direction = Math.atan2(-newDy, -newDx);\n            particle.velocity.angle = particle.direction;\n            break;\n          }\n        default:\n          {\n            if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n              return;\n            }\n            switch (particle.outType) {\n              case \"outside\":\n                {\n                  particle.position.x = Math.floor(randomInRange({\n                    min: -particle.moveCenter.radius,\n                    max: particle.moveCenter.radius\n                  })) + particle.moveCenter.x;\n                  particle.position.y = Math.floor(randomInRange({\n                    min: -particle.moveCenter.radius,\n                    max: particle.moveCenter.radius\n                  })) + particle.moveCenter.y;\n                  var _getDistances3 = getDistances(particle.position, particle.moveCenter),\n                    _dx = _getDistances3.dx,\n                    _dy = _getDistances3.dy;\n                  if (particle.moveCenter.radius) {\n                    particle.direction = Math.atan2(_dy, _dx);\n                    particle.velocity.angle = particle.direction;\n                  }\n                  break;\n                }\n              case \"normal\":\n                {\n                  var wrap = particle.options.move.warp,\n                    canvasSize = container.canvas.size,\n                    newPos = {\n                      bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                      left: -particle.getRadius() - particle.offset.x,\n                      right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                      top: -particle.getRadius() - particle.offset.y\n                    },\n                    sizeValue = particle.getRadius(),\n                    nextBounds = calculateBounds(particle.position, sizeValue);\n                  if (direction === \"right\" && nextBounds.left > canvasSize.width + particle.offset.x) {\n                    particle.position.x = newPos.left;\n                    particle.initialPosition.x = particle.position.x;\n                    if (!wrap) {\n                      particle.position.y = getRandom() * canvasSize.height;\n                      particle.initialPosition.y = particle.position.y;\n                    }\n                  } else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                    particle.position.x = newPos.right;\n                    particle.initialPosition.x = particle.position.x;\n                    if (!wrap) {\n                      particle.position.y = getRandom() * canvasSize.height;\n                      particle.initialPosition.y = particle.position.y;\n                    }\n                  }\n                  if (direction === \"bottom\" && nextBounds.top > canvasSize.height + particle.offset.y) {\n                    if (!wrap) {\n                      particle.position.x = getRandom() * canvasSize.width;\n                      particle.initialPosition.x = particle.position.x;\n                    }\n                    particle.position.y = newPos.top;\n                    particle.initialPosition.y = particle.position.y;\n                  } else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                    if (!wrap) {\n                      particle.position.x = getRandom() * canvasSize.width;\n                      particle.initialPosition.x = particle.position.x;\n                    }\n                    particle.position.y = newPos.bottom;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                  break;\n                }\n            }\n            break;\n          }\n      }\n    }\n  }]);\n  return OutOutMode;\n}();","map":{"version":3,"names":["Vector","calculateBounds","getDistances","getRandom","isPointInside","randomInRange","OutOutMode","container","_classCallCheck","modes","_createClass","key","value","update","particle","direction","delta","outMode","includes","outType","_particle$velocity","velocity","vx","x","vy","y","circVec","origin","length","moveCenter","radius","angle","Math","PI","addTo","create","_getDistances","position","dx","dy","floor","min","max","canvas","size","width","height","_getDistances2","newDx","newDy","atan2","getRadius","_getDistances3","wrap","options","move","warp","canvasSize","newPos","bottom","offset","left","right","top","sizeValue","nextBounds","initialPosition"],"sources":["C:/Users/Polymorph/Desktop/face_recognizer/face_recognition_app/SmartBrains/node_modules/tsparticles-updater-out-modes/esm/OutOutMode.js"],"sourcesContent":["import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"tsparticles-engine\";\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= 0 && dx >= 0) || (vy <= 0 && dy >= 0) || (vx >= 0 && dx <= 0) || (vy >= 0 && dy <= 0)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const wrap = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}